# 冒泡排序

## 算法原理

> 比较相邻两个元素之间的大小，那么每一次就会将最大的排序到最后面
>
> 第一次遍历从第一个元素到最后一个元素，将最大的排序到最后面
>
> 第二次遍历从第一个元素到倒数第二个元素，将第二大的排序到倒数第二个位置
>
> 以此类推
>
> ......
>
> ......
>
> 就可以得到一个排序好的序列

可以参考https://zhuanlan.zhihu.com/p/42586566中的算法图

![动图](../images/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

冒泡排序适用于小数据的排序，不适用于数据量大的时候

对冒泡排序进行<mark>优化</mark>：可以增加一个swap变量，当前一轮没有进行交换的时候，说明数组已经有序了，就不用再进行下一轮的循环了，直接退出。

## 时间空间复杂度

### 时间复杂度

| 情况         | 原因                                                         | 时间复杂度 |
| ------------ | ------------------------------------------------------------ | ---------- |
| 最坏（逆序） | 每对元素都要比较和交换                                       | O(n^2)     |
| 平均         | 数据随机分布，比较次数还是约n^2 /2                           | O(n^2)     |
| 最好（有序） | 加了 `swapped` 标志位，一轮内无交换即可提前终止循环，虽然序列有序但是也得遍历一次才知道是否有序，所以时间复杂度是O(n) | O(n)       |

### 空间复杂度

冒泡排序是原地排序算法，没有用到额外的数组、堆或者递归栈，所以空间复杂度是O(1)

# 选择排序

## 算法原理

> 

