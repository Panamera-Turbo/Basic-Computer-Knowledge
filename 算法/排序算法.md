# 冒泡排序

## 算法原理

> 1. 第一次遍历从第一个元素到最后一个元素，两两比较大小，那么就会将最大的排序到最后面
>
> 2. 第二次遍历从第一个元素到倒数第二个元素，两两比较大小，那么就会将第二大的排序到倒数第二个位置
>
> 以此类推
>
> ......
>
> 就可以得到一个排序好的序列

## 代码

```python
def bubble(l):
    for _ in range(len(l) - 1): 	# 对于一个长度为n的数组，要进行n-1次的冒泡排序
        for i in range(len(l) - 1): # 内存循环进行一次冒泡排序
            if l[i] > l[i + 1]:
                tmp = l[i]
                l[i] = l[i + 1]
                l[i + 1] = tmp

    return l

l = [1, 3, 8, 6, 5, 7, 9, 3, 6, 5]
print(bubble(l))
```

可以参考https://zhuanlan.zhihu.com/p/42586566中的算法图

![动图](../images/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

> 稳定排序：遇到数值相同的元素，排序前后的相对位置会不会保持不变

冒泡排序是稳定排序，冒泡排序适用于小数据的排序，不适用于数据量大的时候。

对冒泡排序进行<mark>优化</mark>：可以增加一个swap变量，当前一轮没有进行交换的时候，说明数组已经有序了，就不用再进行下一轮的循环了，直接退出。

## 时间空间复杂度

### 时间复杂度

| 情况         | 原因                                                         | 时间复杂度 |
| ------------ | ------------------------------------------------------------ | ---------- |
| 最坏（逆序） | 每对相邻元素都要比较并在必要时交换                           | O(n²)      |
| 平均         | 数据随机分布下，比较次数约 n²/2                              | O(n²)      |
| 最好（有序） | 加入 swapped 标志位，一轮内无交换即可提前终止循环，需一次遍历以确认有序 | O(n)       |

### 空间复杂度

冒泡排序是原地排序算法，没有用到额外的数组、堆或者递归栈，所以空间复杂度是O(1)

# 选择排序

## 算法原理

> 1. 选择序列中最小的元素放在第一个
> 2. 从剩下的序列中选择最小的元素放在第二个
>
> 以此类推
>
> ......
>
> 就可以得到一个排序好的序列

可以参考https://zhuanlan.zhihu.com/p/42586566中的算法图

![动图](../images/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

选择排序是不稳定的算法，因为排序后可能会导致前后的相对位置不一样。选择排序是优先于冒泡排序的，选择排序也是适用于简单的数据排序。

```markdown

1. 第 1 轮（i = 0）
   区间 [0..3] 最小值是 (3, D)，交换后：
   [(3, D), (5, B), (4, C), (4, A)]


2. 第 2 轮（i = 1）
   区间 [1..3] 最小值是 (4, C)，交换位置 1 和 2：
   [(3, D), (4, C), (5, B), (4, A)]


3. 第 3 轮（i = 2）
   区间 [2..3] 最小值是 (4, A)，交换位置 2 和 3：
   [(3, D), (4, C), (4, A), (5, B)]


4. 第 4 轮（i = 3）
   只有一个元素，不需要操作。

最终的结果是 [(3, D), (4, C), (4, A), (5, B)]，改变了原始的顺序
```

## 代码

```python
def select(l):
    min = 0
    i = 0
    for i in range(len(l)):  # 将位置i的元素和后面进行对比，每次选取最小的元素并放入到l[min]中
        min = i
        for j in range(i + 1, len(l)):   
            if l[j] < l[min]:
                min = j
                
        if min != i:
            tmp = l[i]
            l[i] = l[min]
            l[min] = tmp
        
    return l
            
l = [1, 3, 8, 6, 5, 7, 9, 3, 6, 5]
print(select(l))
```

## 时间空间复杂度

### 时间复杂度

| 情况         | 原因                                                     | 时间复杂度 |
| ------------ | -------------------------------------------------------- | ---------- |
| 最坏（逆序） | 每一轮都要在未排序区间扫描找最小值并与当前位置交换       | O(n²)      |
| 平均         | 数据随机分布，比较次数依然约 n²/2                        | O(n²)      |
| 最好（有序） | 即使序列有序，也没有提前退出机制，依然要完整扫描剩余区间 | O(n²)      |

### 空间复杂度

选择排序是原地排序算法，没有用到额外的数组、堆或者递归栈，所以空间复杂度是O(1)

# 插入排序

## 算法思路

> 1. 将一个元素视为已经排序好的，，然后从第二个元素开始在排序好的子数组中找到合适的位置进行插入
> 2. 由于前两个元素已经成为排序好的数组了，所以第三个元素就去寻找要放在前两个的哪个位置合适即可
>
> 以此类推
>
> ......
>
> 就可以得到一个排序好的序列

可以参考https://zhuanlan.zhihu.com/p/42586566中的算法图

![动图](../images/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)

插入排序是稳定的排序方法，适用于数组较小的情况，不适用于数组较大的情况

## 代码

```python
def insert(l):
    for i in range(1, len(l)):          # 前面的[0, i]视为已经排序过的
        value = l[i]                    # 待插入的元素
        
        j = i - 1
        while(j > 0 and l[j] > value):  
            l[j + 1] = l[j]             # 如果已排序的比待插入的元素大，那么就将已排序的元素往后移动一位，给待排序的元素留位置
            j -= 1
            
        l[j + 1] = value
        
    return l

l = [1, 3, 8, 6, 5, 7, 9, 3, 6, 5]
print(insert(l))
```

## 时间空间复杂度

### 时间复杂度

| 情况         | 描述                                              | 时间复杂度 |
| ------------ | ------------------------------------------------- | ---------- |
| 最坏（逆序） | 每次插入都要与已排序区所有元素比较并移动          | O(n²)      |
| 平均         | 随机分布时，元素平均要移动已排序区长度的一半      | O(n²)      |
| 最好（有序） | 已排序区每次只需一比较，无需移动，只做 n–1 次检查 | O(n)       |

### 空间复杂度

原地排序，仅使用常量级额外空间，所以空间复杂度是O(1)

