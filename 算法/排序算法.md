# 冒泡排序

## 算法原理

> 1. 第一次遍历从第一个元素到最后一个元素，两两比较大小，那么就会将最大的排序到最后面
>
> 2. 第二次遍历从第一个元素到倒数第二个元素，两两比较大小，那么就会将第二大的排序到倒数第二个位置
>
> 以此类推
>
> ......
>
> ......
>
> 就可以得到一个排序好的序列

可以参考https://zhuanlan.zhihu.com/p/42586566中的算法图

![动图](../images/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

> 稳定排序：遇到数值相同的元素，排序前后的相对位置会不会保持不变

冒泡排序是稳定排序，冒泡排序适用于小数据的排序，不适用于数据量大的时候。

对冒泡排序进行<mark>优化</mark>：可以增加一个swap变量，当前一轮没有进行交换的时候，说明数组已经有序了，就不用再进行下一轮的循环了，直接退出。

## 时间空间复杂度

### 时间复杂度

| 情况         | 原因                                                         | 时间复杂度 |
| ------------ | ------------------------------------------------------------ | ---------- |
| 最坏（逆序） | 每对相邻元素都要比较并在必要时交换                           | O(n²)      |
| 平均         | 数据随机分布下，比较次数约 n²/2                              | O(n²)      |
| 最好（有序） | 加入 swapped 标志位，一轮内无交换即可提前终止循环，需一次遍历以确认有序 | O(n)       |

### 空间复杂度

冒泡排序是原地排序算法，没有用到额外的数组、堆或者递归栈，所以空间复杂度是O(1)

# 选择排序

## 算法原理

> 1. 选择序列中最小的元素放在第一个
> 2. 从剩下的序列中选择最小的元素放在第二个
>
> 以此类推
>
> ......
>
> ......
>
> 就可以得到一个排序好的序列

可以参考https://zhuanlan.zhihu.com/p/42586566中的算法图

![动图](../images/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

选择排序是不稳定的算法，因为排序后可能会导致前后的相对位置不一样。选择排序是优先于冒泡排序的，选择排序也是适用于简单的数据排序。

```markdown

1. 第 1 轮（i = 0）
   区间 [0..3] 最小值是 (3, D)，交换后：
   [(3, D), (5, B), (4, C), (4, A)]


2. 第 2 轮（i = 1）
   区间 [1..3] 最小值是 (4, C)，交换位置 1 和 2：
   [(3, D), (4, C), (5, B), (4, A)]


3. 第 3 轮（i = 2）
   区间 [2..3] 最小值是 (4, A)，交换位置 2 和 3：
   [(3, D), (4, C), (4, A), (5, B)]


4. 第 4 轮（i = 3）
   只有一个元素，不需要操作。

最终的结果是 [(3, D), (4, C), (4, A), (5, B)]，改变了原始的顺序
```

## 时间空间复杂度

### 时间复杂度

| 情况         | 原因                                                     | 时间复杂度 |
| ------------ | -------------------------------------------------------- | ---------- |
| 最坏（逆序） | 每一轮都要在未排序区间扫描找最小值并与当前位置交换       | O(n²)      |
| 平均         | 数据随机分布，比较次数依然约 n²/2                        | O(n²)      |
| 最好（有序） | 即使序列有序，也没有提前退出机制，依然要完整扫描剩余区间 | O(n²)      |

### 空间复杂度

选择排序是原地排序算法，没有用到额外的数组、堆或者递归栈，所以空间复杂度是O(1)