回溯算法和递归都是相辅相成的，回溯算法一般都是在递归函数的下面

# 解决的问题

组合问题（不强调元素顺序），切割问题，子集问题，排列问题（强调元素顺序），棋盘问题

回溯算法可以解决的问题基本都是可以抽象成为N叉树的。

> 对于N叉树的宽度可以采用for循环来进行处理的，N叉树的深度可以采用递归的方式进行处理。
>
> 像一个树形结构的东西，for循环是从左往右遍历；
>
> 然后从上到下就是一层一层的是采用递归来解决的。

```bash
# 就比如Leetcode 131题目中的分割回文串的问题，可以对应下面的树状结构（先往下走，然后再一步一步上去往右边走）

                   ["a", "a", "b"]
          /                        \
       "a"                       "aa"
     /     \                      /    \
  "a"     "ab"(×)           "b"        "aab"(×)
 /           \
"b"        (终点无效)
 |
 (终点) → ["a","a","b"]
```
回溯法的递归的返回值一般都是void，回溯的终止条件一般就是<mark>收集结果的时候，然后就可以return，不要忘记return</mark>

# 模板

回溯操作模板

```python
def backtracking(参数) :
    if (终止条件) {
        存放结果;
        return;
    }

    for (处理本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); # 递归，要处理下一层的节点
        回溯，撤销处理结果            # 递归下面就是回溯的结果
    }
```

> 在相同的集合里面求组合的话要用startIndex，但是在不同的集合里面求组合的话就不要用startIndex。可以看leetcode子集以及电话号码的数字组合的差别
>

# 组合问题

组合问题就是要考虑数字的先后顺序，例如[1, 2]和[2, 1]是两个一样的组合，所以要用startIndex来控制开始的顺序。

# 排列问题

组合和排列不同的地方在于组合是不考虑数字的先后顺序的，但是排列会考虑到数字的先后顺序的，所以在排列问题中得用used数组表示哪个元素已经访问过了，哪个元素还没访问。

# 括号问题



括号生成 的问题其实是有约束的排列问题

解题思路和前面的组合和排列是一样的，先用树形的结构画出整个路径，然后判断什么时候要退出递归

```bash
可以根据左括号和右括号的数量来进行判断。
当右括号的数量比左括号多的话，也就是右括号开头的话，代表这是一个无效的匹配，那么这条路径就会断掉。然后当左右括号的数量一样多都等于n的话，那么就说明是合法的括号生成
然后还有一个很关键的是：什么时候加入"("，什么时候加入")"，当左括号的数量小于n的话就加左括号，当右括号的数量小于左括号的时候就加入右括号
```



