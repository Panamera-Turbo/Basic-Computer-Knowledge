# MySQL

## VIEW

VIEW视图本身不存储数据，是建立在一个或者多个表的虚拟表，而是保存了一条查询语句。当查询视图时，数据库系统会将视图的定义（保存的查询语句）与用户的查询语句结合起来，生成一个完整的查询语句，然后直接对原始的表进行查询。

```sql
--假设这样创建视图

CREATE VIEW EmployeeInfo AS
SELECT employee.name, employee.department
FROM employee;

--用户的查询语句如下
SELECT * FROM EmployeeInfo WHERE department = 'Sales';

--数据库系统实际的操作是这样的
SELECT employee.name, employee.department
FROM employee
WHERE employee.department = 'Sales';
```

特点：

1. 逻辑抽象：可以将复杂的多表JOIN，过滤条件、计算表达式等封装进视图，客户端只需要进行简单的查询即可

```sql
--创建一个新的视图

CREATE VIEW vip_user_order_stats AS
SELECT
    u.username,
    SUM(od.quantity) AS total_products,
    SUM(od.quantity * od.price) AS total_amount,
    AVG(od.quantity * od.price) AS avg_amount
FROM
    orders o
JOIN
    users u ON o.user_id = u.user_id
JOIN
    order_details od ON o.order_id = od.order_id
WHERE
    u.user_level = 'VIP'
    AND o.order_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
GROUP BY
    u.username;
    
-- 用户查询的时候只需要简单的查询语句就可以获取需要的数据

SELECT * FROM vip_user_order_stats;
```

2. 安全隔离：可以给某些用户访问特定视图的权限，而不是暴露基础表的全部行或者列

3. 更新限制：

   简单视图（基于单表、直接列投影、无聚合、无 `DISTINCT`、无子查询、无计算列）通常可以 `INSERT`/`UPDATE`/`DELETE`

   复杂视图（多表关联、聚合、分组等）一般只读，不能直接修改



## 索引

二叉搜索树，AVL树，红黑树都是在内存中进行的，这些树都是比较小的，无法处理硬盘中较多的数据，所以硬盘中的数据采用的是B/B+树来进行检索

### B树

可以看这个视频：https://www.bilibili.com/video/BV1tJ4m1w7yR?spm_id_from=333.788.videopod.sections&vd_source=d5336924b1b9449b7d38d5ca22bd9019

B树的特点

> 1. 平衡：所有的叶节点都在同一层，都在最后一层
>
> 2. 有序：元素的左子树都是小于当前元素，右子树都是大于当前元素
>
> 3. 多路：对于m阶的B树结点：
>
>    最多：m个分支，m - 1个元素
>
>    最少：根节点要有：2个分支，1个元素；其他节点：（m/2向上取整）个分支，（m/2向上取整-1）个元素

**插入**

> 1. 先查找插入的位置进行插入
> 2. 如果没有上溢出则无需调整
> 3. 否则中间元素(m/2向上取整)上移，两边分裂

例如：3阶B树的话，那么中间元素就是3/2向上取整就是2，那么就是将第二个元素进行分裂

**删除**

> 删除非叶子节点的话其实就会转换成为叶子节点的删除的
>
> 删除的是叶节点元素：
>
> 1. 没有溢出则无需调整
> 2. 下溢出（就是结点的元素不够）：（1） 找兄弟借，兄弟够借的话那么就是父结点下来，兄弟结点上去
>
> （2）找兄弟借，兄弟不够借（可能导致父结点下溢出）：父结点下移到左边，然后右边的合并过来

### B+树

B+树的特点

顺序查找：逐个搜索数据中的每一项直到找到想要的元素

随机查找：直接定位到目标元素的所在位置

范围查找：查找满足区间条件的所有元素（例如查找10~50的话，那么就先查找10，然后再查找50）

> 和B树不同的是：
>
> m阶的B+树<mark>最多</mark>有m个分支，每个分支<mark>最多</mark>有m个结点（而不是B树的m-1个结点）
>
> B+树可以直接在叶结点进行查找，因为叶子结点也有一个head头指针，但是B树只能通过中序遍历进行查找
>
> B+树兼顾顺序查找和随机查找，还可以很方便进行范围查找

B树是所有结点的关键字都有指向对应记录的指针，但是B+树的话不是这样的，B+树只有<mark>叶子结点</mark>包含关键字以及指向对应记录的指针，非叶子结点只做索引

![image-20250413113656601](images/image-20250413113656601.png)

与红黑树的不同，B+树的优点

> 1. 红黑树本质是二叉树，所以每个结点只有一个元素，但是B/B+树每个结点不止一个元素，所以就会有更低的树高
> 2. 磁盘访问是按“页”来读的，B/B+树的设计是将一个节点大小设计为一个磁盘页的大小，那么每次I/O操作都会读取一整页的数据
> 3. 利用磁盘预读（每次读取的时候会将邻居的也一起读出来），B+ 树的 叶子节点是顺序连接的，但是红黑树的是分散的，所以B+树更适合文件系统

### MySQL索引

索引的作用是加快查找数据的速度，就像是书本的目录一样

下面三种情况不适合使用索引：

1. 数据量很小的时候，只需要从头开始遍历就好了，不需要索引
2. 搜索结果会返回大量数据，此时会找到对应的主键然后再根据主键去表里查数据，不如直接从头遍历到尾巴
3. 频繁更新的数据，更新数据不只是更新数据的值也得更新数据的索引，例如在B+树中更新数据的话，会导致树对应的索引改变

**B+树索引**

InnoDB 的 B+Tree 索引分为主索引和辅助索引。

> <mark>主索引</mark>是以主键为key构造的B+树索引，里面的叶子结点存储的是完整的数据记录，这种索引方式被称为聚簇索引，每个表只有一个聚簇索引
>
> <mark>辅助索引</mark>>是非主键为key对应构造的B+树索引，B+树叶子结点没有数据记录，是存储着非主键对应的主键值
>
>
> 流程：
>
> 如果是用的是主键进行查找的话，那么就直接去主索引里面的叶子结点查找对应的数据（例如：where id=xxx）
>
> 如果用的是非主键进行查找的话，就会先根据辅助索引找到对应的主键，然后按照主键去主索引的叶子结点找数据

**哈希索引**

哈希索引适用于等值查找（例如：SELECT * FROM Employee WHERE department = 'Sales';），不支持范围查找和部分查找。

将要查询的值进行哈希计算然后看是属于哪个槽呢，例如Sales可能经过哈希计算后结果是587，然后直接定位到存储 'Sales' 的桶，桶里面存放的是数据指针，数据指针对应的是磁盘中的值

**全文索引**

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。适用于查找文中的关键字，而不是直接比较是否相等

MyISAM（MySQL早期的存储引擎）支持全文索引，记录着关键词到其所在文档的映射

**空间数据索引**

当数据具有二维或多维坐标，可通过空间索引高效进行

多维数据往往具有空间聚集特性，空间索引可以将相近的数据存储在同一区域内，通过树的分层结构迅速定位到目标区域

### 索引优化

| 查询条件         | 是否使用索引 | 原因                         |
| ---------------- | ------------ | ---------------------------- |
| `LIKE '索引%'`   | ✅ 可以       | 开头匹配，能用索引加速       |
| `LIKE '%索引'`   | ❌ 不行       | 以 `%` 开头，无法利用索引    |
| `LIKE '%索引%'`  | ❌ 不行       | 同上，必须全表扫描           |
| `LIKE '索引___'` | ✅ 可以       | 固定前缀长度匹配，仍可用索引 |

**独立的列**

针对一个字段建立索引（如果是下面的语句的话，那么就对actor_id建立索引）

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id = 5;
```

**多级索引**

针对多个字段建立索引，例如actor_id和film_id字段建立索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

**索引列的顺序**

让<mark>索引选择性</mark>最强的索引放在最前面

索引的选择性是：不重复的索引值和记录总数的比值。选择性越高表示区分度越高，查询效率也越高

**前缀索引**

对于 BLOB（非结构化二进制文件例如图像什么的）、TEXT（大段文字内容例如博客什么的） 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符

**覆盖索引**

如果一次查询所需要的所有字段都能在索引中找到，就称为覆盖索引

例如下面的代码，为users表的name，age创建索引，那么下面查询age和name的时候就命中了索引，这就是覆盖索引

```sql
CREATE INDEX idx_name_age ON users(name, age);
SELECT age FROM users WHERE name = 'Tom';
```

**索引优化的优点**：

1. 索引通常远小于数据行的大小，只读取索引可以大大减少数据访问量
2. 一些存储引擎(例如MyISAM)在内存中只缓存索引（只有少部分数据在内存中），而数据是依赖于操作系统来缓存（其他大部分数据是在磁盘中的，需要的时候由操作系统调用进入内存）的，所以可以只访问索引而不进行系统调用
3. 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

**索引的优点**

1. 大大减少了服务器需要扫描的数据行数
2. 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）
3. 将随机的I/O变成顺序I/O（就是访问局部性原理，访问当前的元素很有可能会访问其邻近的元素，顺序I/O就能很好的读取临近的元素）

**索引的使用条件**

1. 对于很小的表来说，大部分情况下全表扫描会比建立索引更加高效
2. 对于中大型表，索引非常有效
3. 对于需要频繁插入删除数据的表来说，维护索引会有比较大的代价
4. 对于特大型的表，维护和建立索引的代价会随之增长，这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术（就是将一张大的表按照规则拆成多张逻辑子表，例如orders表有 5 亿条数据，你可以按年份进行子表的建立）

## 查询性能优化

索引和查询性能的区别：索引是工具，查询性能是结果表现

查询性能包括索引，SQL语句以及表结构设计

### Explain

使用Explain可以分析SELECT查询语句，会告诉我们查询语句是如何进行的

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数

### 优化数据访问

**减少请求的数据量**

只返回必要的列：最好不要用SELECT *

只返回必要的行：使用LIMIT语句来限制返回的数据

缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别是对于要被重复查询的数据，缓存的性能提升很明显

**减少服务端扫描的行数**

扫描的行数意思是就是需要检索多少行的数据，最有效的方法就是使用覆盖索引

### 重构查询方式

重构查询方式的意思是：在不改变查询结果的前提下，对SQL语句进行改写或调整结构

**切分大查询**

下面的DELETE是一条删除语句，如果删除的数据有几百万行的话，那么就可能一次性锁住很多的数据，占满整个事务日志

```sql
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);

# 切分上面的大查询语句为小的语句
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

**分解大连接查询**

JOIN的几个类型

| JOIN 类型         | 说明                                              |
| ----------------- | ------------------------------------------------- |
| `INNER JOIN`      | **只返回匹配的行**（最常用）                      |
| `LEFT JOIN`       | 返回左表所有行，即使右表没有匹配                  |
| `RIGHT JOIN`      | 返回右表所有行，即使左表没有匹配                  |
| `FULL OUTER JOIN` | 返回左右表所有行（MySQL 不支持，可用 UNION 模拟） |
| `CROSS JOIN`      | 笛卡尔积（每行都和另一表的每行配对）              |

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

1. 缓存更高效，因为如果分解成为多个查询之后，那么即使一个表发生变化，其他表的查询缓存依然可以使用（当你执行一条查询时，如果这条SQL和它涉及的表**都没有发生变化**，那么下一次执行这条相同的查询就可以**直接返回缓存的结果**，不用再执行一遍。）
2. 分解成为多个查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询（SELECT name FROM users WHERE id = 1; 例如得到这个结果的话，那么其他查询语句可能也是想要得到这个结果，那么其他也可以用）
3. 减少锁竞争；
4. 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。

> 传统的做法，多个表必须<mark>在同一个数据库里</mark>，否则就无法JOIN

✅ 数据库层连接（传统做法）：

```
sql复制编辑SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.id = 1;
```

由数据库自己连接 `users` 和 `orders` 两张表。

> 在应用层连接就是可以使用Python和Java等高级语言进行数据库的连接，多个表可以在<mark>不同的数据库里</mark>，先从各个数据库读取数据然后再用代码进行拼接

✅ 应用层连接（你写代码连接）：

```
# 第一步，在应用程序中执行：
SELECT name FROM users WHERE id = 1;

# 第二步，再执行：
SELECT amount FROM orders WHERE user_id = 1;

# 最后在代码中“拼接”成：
{ "name": "Tom", "orders": [100, 200, ...] }
```

就是你**在应用逻辑中控制“先查谁，再查谁”，再把它们拼起来**。

5. 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';

# 使用IN代替连接查询
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```

## 存储引擎

### InnoDB

是MySQL默认的事务型存储引擎，只有当需要Mysql不支持的其他特性的时候，才会用其他存储引擎

InnDB采用的是聚簇索引，这样查主键时只需要一次 B+ 树遍历即可拿到所有列，避免了二次回表带来的额外随机 I/O。可以通过采用 MVCC+ Next-Key Locking防止幻影读

<mark>注意！！！</mark>

> InnoDB在查找数据的时候，例如查找索引为35的数据，那么会先将35和Buffer pool(缓冲池)中的索引进行对比，如果有的话就直接返回数据，如果没有的话就会到磁盘中查找B+树，找到35对应的叶子节点，叶子节点里面就包含了所有的数据。

针对于InnoDB内部做了很多优化，包括从磁盘读取的时候采用可预测读，能够加快读操作并且创建自适应的哈希索引（数据库检测到某些索引值的访问非常频繁，它会自动在内存中为这些索引值建立哈希索引，那么查找的时候就会很快）。InnoDB会使用插入缓冲区来合并插入操作。插入缓冲区会将多个插入操作合并到一个批量写入操作中，减少磁盘 I/O 的次数。

InnoDB还支持在线热备份，就是在数据库持续对外提供读写服务的情况下，对其数据进行备份

原理：

> 在线热备份就是：
>
> - **不停机器、不停业务**：备份时数据库依然可以读写，不会影响用户操作。
> - **拷贝数据＋记录日志**：把当前的数据文件复制一份，同时记录下这段时间的日志（redo log/二进制日志）。
> - **恢复时合并日志**：把备份的文件恢复到新环境，再把日志按先后顺序“回放”进去，保证数据和你备份时刻完全一致。
>
> 简单来说，就是“数据库在线运行时，安全地把数据复制出来，一会儿再加上中间写入的日志”，就能得到一份完整、可用的备份，而无需停机。

### MyISAM

设计简单，数据以紧密格式存储。适用于只读数据，比较小的表，可以容忍恢复操作，则可以使用MyISAM

提供了压缩表、空间数据索引等。

> 压缩表：就是将MyISAM 表数据文件（*.MYD）压缩成只读格式，就不能再进行插入和删除操作了
>
> 空间数据索引：就是用 R-Tree 管理地理/几何数据的最小外包矩形，加速空间范围与相交查询。

不支持事务

不支持行级锁，只能对整张表进行加锁。读取的时候会对需要读到的所有表加共享锁，写入的时候会对表加排他锁。但是在有表读取操作的时候也可以往表中插入新的记录，这种称为并发插入（CONCURRENT INSERT）但是插入的数据只能插入在表尾。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。<mark>这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</mark>

### 比较

| 特性     | MyISAM                           | InnoDB                              |
| -------- | -------------------------------- | ----------------------------------- |
| 事务     | 不支持事务（无 Commit/Rollback） | 支持事务，可使用 Commit 和 Rollback |
| 并发     | 只支持表级锁（表读写时全表锁）   | 支持行级锁，提高并发粒度            |
| 外键     | 不支持外键                       | 支持外键约束                        |
| 备份     | 不支持真正的在线热备份           | 支持在线热备份                      |
| 崩溃恢复 | 崩溃后易损坏，恢复慢             | 崩溃保护好，恢复速度快              |
| 其它特性 | 支持压缩表、空间数据索引         | 无此特性                            |

## 数据类型

### 整型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。（因为INT是固定的32位存储）

### 浮点数

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价（DECIMAL是由数据库引擎在自己的进程里、通过软件库来完成）。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

### 字符串

主要有 CHAR 和 VARCHAR 两种类型，CHAR是定长的，VARCHAR是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是由于VARCHAR前面都会有1～2 字节来表示长度，所以当UPDATE操作的时候会导致长度变长，变长字段内容变多，自带的长度前缀就变长。就会导致可能会超出一页所能容纳的大小，就需要进行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索的时候，会保留VARCHAR末尾的空格，删除CHAR末尾的空格。

### 时间和日期

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

1. DATETIME 

能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。与时区无关，就是存入什么就显示什么，用这种方式来显示时间的：2008-01-16 22:37:08

2. TIMESTAMP

保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。

和时区有关

MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳

```sql
-- UNIX时间表是从1970 年 1 月 1 日到现在经过的秒数，会是一个很多的数字，例如1683676800

-- 会话时区设为 +08:00
SET time_zone = '+08:00';

-- 数据行中 DATETIME 存的是 '2025-05-10 14:00:00'
INSERT INTO events (created_at) VALUES ('2025-05-10 14:00:00');

-- UNIX_TIMESTAMP 会先把它当成台北时间，
-- 转成 UTC：'2025-05-10 06:00:00 UTC'，
-- 然后算自 1970-01-01 起的秒数，返回 1715373600。
SELECT UNIX_TIMESTAMP(created_at) FROM events;

-- 从 UNIX 时间戳生成带时区的 DATETIME
SELECT FROM_UNIXTIME(1683676800, '%Y-%m-%d %H:%i:%s');
```

## 切分



水平切分和垂直切分

### 水平切分(sharding)

将同一个表中的记录拆分到多个<mark>结构相同</mark>的表中。

![image-20250510120435380](images/image-20250510120435380.png)

### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

![image-20250510120530990](images/image-20250510120530990.png)

**sharding(水平切分)策略**

1. 哈希取模：对分片键（如用户 ID、订单 ID 等）先做哈希运算（将非数字转换成为数字），再对分片总数 N 取模，得到一个 0…N-1 的下标，决定这条记录落到哪个分片（或哪张表、哪台库）。

   优点：

   > 分布均匀：哈希能打散“热门”key，天然避免单点热点；
   >
   > 路由开销小：计算一次哈希＋取模，O(1) 即可直接定位。

2. 范围：

   根据主键或某个列的取值区间来划分，每个分片负责一段连续值或一段时间。

   优点：

   > 范围查询高效：直接定位到一个或少数几个分片就能完成；
   >
   > 扩容灵活：只要新建一个负责新范围的分片。

3. 映射表：

   使用一个单独的数据库来存储映射关系

   优点：

   > 灵活度最高：可以随时调整映射关系（冷热分离、手动迁移）；
   >
   > 支持任意复杂策略：不一定非得哈希或范围，都可以自定义。

**sharding存在的问题**

1. 事务问题：使用分布式的事务来解决，因为数据是存储在不同的数据库上的

2. 连接问题：跨数据库的JOIN是无法在数据库层面解决的，只能在用户程序中进行连接

3. ID唯一性：需要保证不同节点同时生成的ID是不重复的。

   可以使用下面三种方法来实现：

   > - 使用全局唯一 ID（GUID）
   > - 为每个分片指定一个 ID 范围
   > - 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)，就是如下所示：
   >
   > |  1 位符号  | 41 位时间戳 | 5 位数据中心 ID | 5 位机器 ID | 12 位序列号 |
   > |  （始终0） | (毫秒级)    | (最多 32 个)    | (最多 32 个)  | (每毫秒 4096 个) |

## 复制

### 主从复制

主要涉及到三个线程：binlog线程，I/O线程，SQL线程

- binlog线程：负责将主服务器上的数据更改写入Binary log中
- I/O线程：负责从主服务器上读取日志，并写入到从服务器的中继日志（Relay log）
- SQL线程：负责读取中继日志，解释出服务器已经执行的数据更改并在从服务器中执行重放（Replay）（重放就是更新从服务器中的数据）

![image-20250510122805338](images/image-20250510122805338.png)

### 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。最后的ClusterControl主要是负责统一对主从拓扑做监控、告警、自动化运维、备份、故障恢复等。

![image-20250510122904675](images/image-20250510122904675.png)